# [Bronze I] 6174 - 9047 

[문제 링크](https://www.acmicpc.net/problem/9047) 

### 성능 요약

메모리: 31256 KB, 시간: 52 ms

### 분류

구현, 시뮬레이션, 정렬, 문자열

### 문제 설명

<p>1949 년 인도 수학자 Kaprekar 는 Kaprekar 연산을 고안해냈다. Kaprekar 연산은 네 자리 수 중 모든 자리수가 같지 않은 수(1111, 2222 등을 제외한)의 각 자리의 숫자를 재배열해서 만들 수 있는 가장 큰 수와 가장 작은 수를 만들어서 그 차이를 계산하는데, 그 결과로 나온 새로운 숫자를 갖고 같은 과정을 반복하는 것이다. </p>

<p>간단한 연산이지만 Kaprekar 는 이 연산이 놀라운 결과를 보여준다는 것을 발견했다. 올해 연도인 2008 로 그 결과를 알아보자. 2008 로 만들 수 있는 가장 큰 수는 8200 이고 가장 작은 수는 0028 이다. </p>

<ul>
	<li>8200 – 0028 = 8172 </li>
	<li>8721 – 1278 = 7443 </li>
	<li>7443 – 3447 = 3996 </li>
	<li>9963 – 3699 = 6264 </li>
	<li>6642 – 2466 = 4176 </li>
	<li>7641 – 1467 = 6174 </li>
	<li>7641 – 1467 = 6174 </li>
</ul>

<p>6174 에 도달한 다음에는 매번 6174 를 만들어 낸다. 2008 만이 유독 6174 에 도달하는 것이 아니라 한 숫자로 이루어지지 않은 모든 네 자리 수는 Kaprekar 연산을 통해 6174 로 가게 된다. 2008 의 경우 6 단계를 거쳐 6174 로 가게 되었는데, 다른 숫자가 입력으로 주어졌을 때 몇 단계만에 6174 로 가는지 알아내는 프로그램을 작성하시오. </p>

### 입력 

 <p>입력은 표준입력(standard input)을 통해 받아들인다. 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스마다 한 줄에 네 자리 수(1000~9999)가 하나씩 주어진다. 단, 이 숫자는 1111, 2222 처럼 하나의 숫자로 이루어진 수는 제외한다. </p>

### 출력 

 <p>출력은 표준출력(standard output)을 통하여 출력한다. 각 테스트 케이스에 대하여 Kaprekar 연산을 통해 몇 단계 만에 6174가 되는지 한 줄에 하나씩 출력하시오. </p>

