import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 편의상 입력 N은 숫자(문자) 배열 A로 표시, 길이는 n으로 표시
 * 0. 불가능한 경우(-1)는 n이 1이고, A[0] < x인 경우이다.
 * 0.1. n이 2 이상이라면 첫 자리는 비우고 나머지가 전부 숫자 y인 수가 정답이 되기 때문이다.
 * 0.2. n이 1이고 되는 경우는 적당히 x, y, A[0]를 비교하면 찾을 수 있다.
 * 
 * 아래는 n이 2 이상일 때 첫 자리 규칙이다.
 * 1. y < A[0] 이면 y가 n개인 수가 답.
 * 2. A[0] == y 이면 첫 문자로 y가 가능할수도, 불가능할 수도 있음.
 * 2.1. y가 가능하려면 해당 자리 아래를 전부 x로 채울 수 있어야 함. (최소값 이상이어야 함)
 * 2.1.1. 이런 경우는 첫 자리만 y로 채우고 아래자리는 또 따로 채워야한다.
 * 2.2. 전부 채울 수 없다면 x로 시작하고 뒤가 전부 y인 수가 답.
 * 3. x < A[0] < y이면 x로 시작하고 뒤가 전부 y인 수가 답.
 * 4. A[0] == x 이면 x로 시작할 수도 있고, 0으로 시작할 수도 있다.(실제 출력에서 0은 빼야함)
 * 4.1. x가 가능하려면 해당 자리 아래를 전부 x로 채울 수 있어야 함. (최소값 이상이어야 함)
 * 4.1.1. 이런 경우는 첫 자리만 x로 채우고 아래자리는 또 따로 채워야한다.
 * 4.2. x가 불가능하면 0으로 시작하고(출력x) 뒤가 전부 y인 수가 답이 된다.
 * 5. A[0] < x 이면 0으로 시작하고(출력x) 뒤가 전부 y인 수가 답이 된다.
 * 
 * 2.1.1.과 4.1.1.의 경우 첫 자리만 채워진 상태이다.
 * 이 경우 자리를 비슷한 논리로 계속 채워나가야한다.
 * (단, 이 경우로 올 때는 y < A[i - 1]인 경우와 A[i - 1] < x인 경우는 없다.
 * 왜냐하면 해당 경우는 이전 자리에서 다 처리되기 때문이다.)
 * 하지만 여기에서 문제는 이것이다.
 * 2.1.과 4.1.에서 뒤를 x로 전부 채울 수 있냐를 구해야한다.
 * 
 * 끝까지 x로 채울 수 있냐 여부는
 * 54840에서 4를 채울 수 있냐를 볼 때
 * (뒤에서부터)
 * 4는 0이라 못 채운다.
 * 44는 4x이라 뒷 자리 x를 4이상으로 채울 수 있는지 봐야하는데, 앞에서 0이라 못 채웠으니 못 채운다.
 * 444는 8xx로 인해 최소 800이상이므로 채울 수 있다.
 * 4444는 4xxx로 시작하여 뒤를 444로 채울 수 있다면 채울 수 있는데, 바로 앞에서 444로 채울 수 있다고 했으니까 된다.
 * 44444는 5xxxx로 인해 최소 50000이상이므로 채울 수 있다.
 * 즉, 뒤에서부터 미리 되는지 여부를 저장해둘 수 있다.
 */

public class Main {
	static StringBuilder sb;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String Num = br.readLine();
		int[] N = new int[Num.length()];
		for (int i = 0; i < Num.length(); i++) {
			N[i] = Num.charAt(i) - '0';
		}
		sb = new StringBuilder();
		solve(N, 4, 7);
		System.out.print(sb.toString());
	}

	public static void solve(int[] N, int x, int y) {
		/**
		 * 0. 불가능한 경우(-1)는 n이 1이고, A[0] < x인 경우이다.
		 * 0.1. n이 2 이상이라면 첫 자리는 비우고 나머지가 전부 숫자 y인 수가 정답이 되기 때문이다.
		 * 0.2. n이 1이고 되는 경우는 적당히 x, y, A[0]를 비교하면 찾을 수 있다.
		 */
		int n = N.length;
		if (n == 1) {
			int num = N[0];
			if (num < x) {
				sb.append(-1);
			} else if (num < y) {
				if (x == 0) {
					sb.append(-1);
				} else {
					sb.append(x);
				}
			} else {
				sb.append(y);
			}
			return;
		}

		// 맨 뒤에서 해당자리까지 x로 채울 수 있는지
		boolean[] able = new boolean[n + 1];
		able[n] = true;
		for (int i = n - 1; i >= 0; i--) {
			if (N[i] > x) {
				able[i] = true;
			} else if (N[i] == x) {
				able[i] = able[i + 1];
			}
		}
		/*
		 * 54840
		 * 44444o => 5가 있어서 44444로 채울 수 있다.
		 * 4444o => 4라서 밑자리를 봐야하는데, 바로 밑자리가 444로 채워지니까 4444로 채울 수 있다
		 * 444o => 8이 있어서 444로 채울 수 있다.
		 * 44x => 44로 못채운다.
		 * 4x => 4로 못채운다
		 */

		// 첫 자리부터 끝 자리까지 채워나간다.
		for (int i = 0; i < n; i++) {
			if (y < N[i]) {
				// 1. y < A[0] 이면 y가 n개인 수가 답.
				for (int j = i; j < n; j++) {
					sb.append(y);
				}
				break;
			} else if (N[i] < x) {
				// 5. A[0] < x 이면 0으로 시작하고(출력x) 뒤가 전부 y인 수가 답이 된다.
				// 첫 자리에서만 나오는 케이스
				// x보다 작은 수가 필요하면 해당 자리는 비우고, 다음 자리부터 y로 채운 수가 답
				for (int j = i + 1; j < n; j++) {
					sb.append(y);
				}
				break;
			} else if (N[i] == y && able[i + 1]) {
				// 2. A[0] == y 이면 첫 문자로 y가 가능할수도, 불가능할 수도 있음.
				// 2.1. y가 가능하려면 해당 자리 아래를 전부 x로 채울 수 있어야 함. (최소값 이상이어야 함)
				// 2.1.1. 이런 경우는 첫 자리만 y로 채우고 아래자리는 또 따로 채워야한다.
				sb.append(y);
			} else if (x < N[i]) {
				// 2.2. 전부 채울 수 없다면 x로 시작하고 뒤가 전부 y인 수가 답.
				// 3. x < A[0] < y이면 x로 시작하고 뒤가 전부 y인 수가 답.
				if (i != 0 || x != 0) {
					sb.append(x);
				}
				for (int j = i + 1; j < n; j++) {
					sb.append(y);
				}
				break;
			} else if (x == N[i] && able[i + 1]) {
				// 4. A[0] == x 이면 x로 시작할 수도 있고, 0으로 시작할 수도 있다.(실제 출력에서 0은 빼야함)
				// 4.1. x가 가능하려면 해당 자리 아래를 전부 x로 채울 수 있어야 함. (최소값 이상이어야 함)
				// 4.1.1. 이런 경우는 첫 자리만 x로 채우고 아래자리는 또 따로 채워야한다.
				sb.append(x);
			} else {
				// 4.2. x가 불가능하면 0으로 시작하고(출력x) 뒤가 전부 y인 수가 답이 된다.
				for (int j = i + 1; j < n; j++) {
					sb.append(y);
				}
				break;
			}
		}
	}
}
// 아 이거 주석 쓴 거 중에 뭐 하나 잘못썼던 거 같은데 어디 잘못 쓴 코드였더라..