A, B = map(int, input().split())

# 숫자의 힘 기본적으로 3이상 홀수일 때 2임
# 홀수 -> 2로 2
# 짝수일 때는 3이나 4인데, 그 결정은 다음과 같이 됨
# 4 : 4 -> 3 -> 2 => 3
# 4 이후의 2의 제곱수 역시 3으로 나눠지지 않으므로 무조건 3임
# 6 = 2^1 * 3^1 (4 미만 모든 수를 만들 수 있는 소인수 조합): 6 -> '4' => 4
# 18 = 6 * 홀수: 18 -> '4' => 4
# 30 = 6 * 홀수: 30 -> '4' => 4
# 42 = 6 * 홀수: 42 -> '4' => 4
# ...
# 414 = 6 * 홀수: 414 -> '4' => 4
# 420 = 2^2 * 3^1 * 5*1 * 7*1 (8미만 모든 수를 만들 수 있는 소인수 조합) : 420 -> '8' => 4
# 420 * 홀수 : 420 * 홀수 -> '8' => 4
# 360360 = 2^3, 3^2, 5^1, 7^1, 11^1, 13^1 (16미만 모든 수를 만들 수 있는 소인수 조합) : 360360 -> '16' => 4
# ....
# 72201776446800 = 2^4, 3^3, 5^2, 7^1, 11^1, 13^1, 17, 19, 23, 29, 31 (32미만 어쩌구) : 저 큰수 -> '32' => 4
# 64미만은 문제에서 주어진 10^17범위 오버해서 할 필요 없음
# 그리고 18 => 4이지만
# 2~18 중에 18에서 가장 먼저 나누어 떨어지지 않으려면 2^1 * 3^2로 나누어떨어지지 않는다는 소리인데
# 이미 2^1(2)로도 나누어떨어지고, 3^2(9)로도 나누어 떨어졌으므로 18은 무조건 나누어떨어진다.
# 마찬가지로 숫자의 힘이 4인 수 전부 저런식으로 먼저 나누어떨어지기 때문에 숫자의 힘이 5 이상인 수는 없다.
# 또한 저기에서 4인 거는 해당 숫자들(6, 420, ..) * 홀수 이므로 숫자의 힘의 다음 수는 2의 제곱수로 나온다.


prime = []
for i in range(2, 32): # 64범위는 필요없으므로 32범위까지 소수 찾기
    isValid = True
    for p in prime:
        if i % p == 0:
            isValid = False
            break
    if isValid:
        prime.append(i)

expoList = []
for i in range(2, 6): # 찾은 소수로 4, 8, 16, 32보다 낮은 모든 수를 만들 수 있는 소인수 쌍 제작
    tempExpoList = []
    for p in prime:
        if p > 2 ** i:
            break
        expo = 1
        while p ** (expo + 1) < 2 ** i:
            expo += 1
        tempExpoList.append(expo)
    expoList.append(tempExpoList)

def count(n):
    sum = n * 2 # 수의 개수만큼 2
    sum += n // 2 # 짝수 개수만큼 1
    for tempExpoList in expoList: # 짝수 중에 4인거 찾아서 +1해주는 작업
        num = 1 # 6, 420, 360360, 쥰내 큰 수 가 올 곳
        for idx, expo in enumerate(tempExpoList): # 만든 소인수 쌍으로 수 다시 만들기
            num *= prime[idx] ** expo
        if n < num:
            break
        sum += (n + num) // (num * 2)
        # 6, 18, 30, ... 에 대해 + 1
        # 420, 1260, 2100, ... 에 대해 + 1
        # 360360, 계산하기 귀찮다, ... 에 대해 + 1
        # 쥰내 큰 수, 계산하기 귀찮다, ... 에 대해 + 1
    return sum
print(count(B) - count(A - 1))